This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
public/
  vite.svg
src/
  assets/
    react.svg
  components/
    Floor.tsx
    LevelGrid.tsx
    Player.tsx
    Wall.tsx
  levels/
    level1.ts
  scenes/
    Scene.tsx
  types/
    level.ts
  App.css
  App.tsx
  index.css
  main.tsx
  vite-env.d.ts
.eslintrc.json
.gitignore
.prettierrc
eslint.config.js
index.html
package.json
README.md
spec.md
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Files
================================================================

================
File: public/vite.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>

================
File: src/assets/react.svg
================
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>

================
File: src/components/Floor.tsx
================
import { usePlane } from '@react-three/cannon';
import { Mesh } from 'three';
import { CELL_SIZE } from '../types/level';

// Calculate floor size based on a 10x10 grid
const FLOOR_SIZE = CELL_SIZE * 10;

export const Floor = () => {
  // Create a static plane for the floor
  const [ref] = usePlane<Mesh>(() => ({
    rotation: [-Math.PI / 2, 0, 0], // Rotate to be horizontal
    position: [0, 0, 0],
    type: 'Static',
  }));

  return (
    <mesh ref={ref} receiveShadow>
      <planeGeometry args={[FLOOR_SIZE, FLOOR_SIZE]} />
      <meshStandardMaterial color="#444444" />
    </mesh>
  );
};

================
File: src/components/LevelGrid.tsx
================
import { useMemo } from 'react';
import { Wall } from './Wall';
import { LevelData, CellType, CELL_SIZE, WALL_HEIGHT } from '../types/level';

interface LevelGridProps {
  level: LevelData;
}

export const LevelGrid = ({ level }: LevelGridProps) => {
  // Memoize the wall positions to avoid recalculating every frame
  const walls = useMemo(() => {
    const wallPositions: Array<{ position: [number, number, number]; size?: [number, number, number] }> = [];
    
    // Iterate through the grid and create walls
    level.grid.forEach((row, rowIndex) => {
      row.forEach((cell, colIndex) => {
        if (cell === CellType.Wall) {
          // Convert grid coordinates to world coordinates
          const x = (colIndex - level.grid[0].length / 2) * CELL_SIZE;
          const z = (rowIndex - level.grid.length / 2) * CELL_SIZE;
          
          wallPositions.push({
            position: [x, WALL_HEIGHT / 2, z],
            size: [CELL_SIZE, WALL_HEIGHT, CELL_SIZE],
          });
        }
      });
    });
    
    return wallPositions;
  }, [level]);

  return (
    <group>
      {/* Render all walls */}
      {walls.map((wall, index) => (
        <Wall
          key={`wall-${index}`}
          position={wall.position}
          size={wall.size}
        />
      ))}
    </group>
  );
};

================
File: src/components/Player.tsx
================
import {useEffect, useRef, useState} from 'react';
import {useFrame, useThree} from '@react-three/fiber';
import {useBox} from '@react-three/cannon';
import {Mesh, Vector3} from 'three';
import {PointerLockControls} from '@react-three/drei';
import {CELL_SIZE} from '../types/level';

// Movement speed constants
const MOVE_SPEED = 15;
export const PLAYER_HEIGHT = 1.8;
const PLAYER_RADIUS = 0.5;
const DAMPING = 0.2;

interface PlayerProps {
  spawnPosition?: [number, number]; // Grid coordinates [x, z]
}

export const Player = ({ spawnPosition = [0, 0] }: PlayerProps) => {
  // Convert grid coordinates to world coordinates
  const worldX = (spawnPosition[0] - 5) * CELL_SIZE;
  const worldZ = (spawnPosition[1] - 5) * CELL_SIZE;

  const [ref, api] = useBox<Mesh>(() => ({
    mass: 1,
    type: 'Dynamic',
    position: [worldX, PLAYER_HEIGHT / 2, worldZ],
    args: [PLAYER_RADIUS, PLAYER_HEIGHT, PLAYER_RADIUS],
    fixedRotation: true,
    userData: { type: 'player' },
    linearDamping: DAMPING,
  }));

  // Get Three.js camera
  const { camera } = useThree();

  // Set initial camera rotation on mount
  useEffect(() => {
    camera.rotation.set(0, 0, 0);
  }, [camera]);

  // Movement state
  const [movement, setMovement] = useState({
    forward: false,
    backward: false,
    left: false,
    right: false,
  });
  
  // Velocity state
  const velocity = useRef<Vector3>(new Vector3());
  
  // Subscribe to physics body position changes
  useEffect(() => {
    return api.velocity.subscribe((v) => {
      velocity.current.set(v[0], v[1], v[2]);
    });
  }, [api.velocity]);
  
  // Set up keyboard controls
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      switch (e.code) {
        case 'KeyW':
        case 'ArrowUp':
          setMovement((prev) => ({ ...prev, forward: true }));
          break;
        case 'KeyS':
        case 'ArrowDown':
          setMovement((prev) => ({ ...prev, backward: true }));
          break;
        case 'KeyA':
        case 'ArrowLeft':
          setMovement((prev) => ({ ...prev, left: true }));
          break;
        case 'KeyD':
        case 'ArrowRight':
          setMovement((prev) => ({ ...prev, right: true }));
          break;
      }
    };
    
    const handleKeyUp = (e: KeyboardEvent) => {
      switch (e.code) {
        case 'KeyW':
        case 'ArrowUp':
          setMovement((prev) => ({ ...prev, forward: false }));
          break;
        case 'KeyS':
        case 'ArrowDown':
          setMovement((prev) => ({ ...prev, backward: false }));
          break;
        case 'KeyA':
        case 'ArrowLeft':
          setMovement((prev) => ({ ...prev, left: false }));
          break;
        case 'KeyD':
        case 'ArrowRight':
          setMovement((prev) => ({ ...prev, right: false }));
          break;
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
    };
  }, []);
  
  // Update player position and camera
  useFrame(() => {
    // Calculate movement direction based on camera orientation
    const direction = new Vector3();
    const frontVector = new Vector3(0, 0, Number(movement.backward) - Number(movement.forward));
    const sideVector = new Vector3(Number(movement.left) - Number(movement.right), 0, 0);
    
    direction
      .subVectors(frontVector, sideVector)
      .normalize()
      .multiplyScalar(MOVE_SPEED)
      .applyEuler(camera.rotation);
    
    // Apply movement to physics body
    api.velocity.set(direction.x, velocity.current.y, direction.z);
    
    // Update camera position to follow player
    ref.current?.getWorldPosition(camera.position);
    camera.position.y = PLAYER_HEIGHT - 0.2;
  });
  
  return (
    <>
      {/* Player physics body (invisible) */}
      <mesh ref={ref} visible={false}>
        <boxGeometry args={[PLAYER_RADIUS * 2, PLAYER_HEIGHT, PLAYER_RADIUS * 2]} />
        <meshStandardMaterial color="red" transparent opacity={0.5} />
      </mesh>
      
      {/* Pointer lock controls for mouse look */}
      <PointerLockControls />
    </>
  );
};

================
File: src/components/Wall.tsx
================
import { useBox } from '@react-three/cannon';
import { Mesh } from 'three';

interface WallProps {
  position: [number, number, number];
  size?: [number, number, number];
  color?: string;
}

export const Wall = ({ position, size = [1, 2, 1], color = '#8B4513' }: WallProps) => {
  // Create a static box for the wall
  const [ref] = useBox<Mesh>(() => ({
    type: 'Static',
    position,
    args: size,
  }));

  return (
    <mesh ref={ref} castShadow receiveShadow>
      <boxGeometry args={size} />
      <meshStandardMaterial color={color} />
    </mesh>
  );
};

================
File: src/levels/level1.ts
================
import { LevelData, EnemyType } from '../types/level';

export const level1: LevelData = {
  name: 'Level 1: Training Ground',
  grid: [
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
    [1, 0, 0, 0, 0, 0, 1, 3, 0, 1],
    [1, 0, 1, 0, 1, 0, 1, 1, 2, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 1, 0, 4, 0, 1, 0, 0, 1],
    [1, 0, 1, 0, 0, 0, 1, 0, 0, 1],
    [1, 0, 1, 1, 0, 1, 1, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
  ],
  enemies: [
    { position: [2, 2], type: EnemyType.Grunt },
    { position: [7, 7], type: EnemyType.Guard, rotation: Math.PI },
  ],
  playerSpawn: [4, 4], // Center of the map
};

================
File: src/scenes/Scene.tsx
================
import { Canvas } from '@react-three/fiber';
import { useRef } from 'react';
import { Physics } from '@react-three/cannon';
import { Player, PLAYER_HEIGHT } from '../components/Player';
import { Floor } from '../components/Floor';
import { LevelGrid } from '../components/LevelGrid';
import { Sky, Stats } from '@react-three/drei';
import { level1 } from '../levels/level1';

export const Scene = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);

  return (
    <Canvas
      ref={canvasRef}
      camera={{
        position: [0, PLAYER_HEIGHT, 5],
        rotation: [0, 0, 0],
        fov: 75
      }}
      style={{ width: '100%', height: '100%' }}
      shadows
    >
      {/* Sky for better visuals */}
      <Sky sunPosition={[100, 10, 100]} />
      
      {/* Lights */}
      <ambientLight intensity={0.5} />
      <directionalLight
        position={[10, 10, 10]}
        intensity={1}
        castShadow
        shadow-mapSize-width={1024}
        shadow-mapSize-height={1024}
      />

      {/* Physics world */}
      <Physics 
        gravity={[0, -30, 0]} 
        defaultContactMaterial={{
          friction: 0.1,
          restitution: 0.1,
        }}
        iterations={20}
      >
        {/* Player with spawn position from level data */}
        <Player spawnPosition={level1.playerSpawn} />
        
        {/* Floor */}
        <Floor />
        
        {/* Level Grid */}
        <LevelGrid level={level1} />
      </Physics>
      
      {/* Performance stats */}
      <Stats />
    </Canvas>
  );
};

================
File: src/types/level.ts
================
// Cell types in the level grid
export enum CellType {
  Empty = 0,
  Wall = 1,
  Door = 2,
  Key = 3,
  PlayerSpawn = 4,
  EnemySpawn = 5,
}

// Enemy types that can spawn in the level
export enum EnemyType {
  Grunt = 'grunt',
  Guard = 'guard',
  Boss = 'boss',
}

// Enemy spawn point definition
export interface EnemySpawn {
  position: [number, number]; // Grid coordinates [x, z]
  type: EnemyType;
  rotation?: number; // Initial rotation in radians
}

// Level definition interface
export interface LevelData {
  grid: CellType[][]; // 2D array representing the level layout
  enemies: EnemySpawn[];
  name: string;
  playerSpawn?: [number, number]; // Optional specific player spawn point [x, z]
}

// Cell size for converting grid coordinates to world coordinates
export const CELL_SIZE = 2; // Each cell is 2x2 units
export const WALL_HEIGHT = 2.5; // Standard wall height

================
File: src/App.css
================
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  overflow: hidden;
}

.app {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
}

#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

================
File: src/App.tsx
================
import { Scene } from './scenes/Scene';
import './App.css';

function App() {
  return (
    <div className="app">
      <Scene />
    </div>
  );
}

export default App;

================
File: src/index.css
================
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#root {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
}

canvas {
  width: 100% !important;
  height: 100% !important;
  outline: none;
}

:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

================
File: src/main.tsx
================
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)

================
File: src/vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: .eslintrc.json
================
{
  "env": {
    "browser": true,
    "es2021": true
  },
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:react/recommended",
    "plugin:react-hooks/recommended",
    "prettier"
  ],
  "parser": "@typescript-eslint/parser",
  "parserOptions": {
    "ecmaFeatures": {
      "jsx": true
    },
    "ecmaVersion": "latest",
    "sourceType": "module"
  },
  "plugins": ["react", "@typescript-eslint", "prettier"],
  "rules": {
    "react/react-in-jsx-scope": "off",
    "prettier/prettier": "error",
    "@typescript-eslint/explicit-module-boundary-types": "off",
    "@typescript-eslint/no-explicit-any": "warn"
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}

================
File: .gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

================
File: .prettierrc
================
{
  "semi": true,
  "tabWidth": 2,
  "printWidth": 100,
  "singleQuote": true,
  "trailingComma": "es5",
  "bracketSpacing": true,
  "jsxBracketSameLine": false
}

================
File: eslint.config.js
================
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "w3d",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "lint:fix": "eslint . --ext ts,tsx --fix",
    "format": "prettier --write \"src/**/*.{ts,tsx}\"",
    "preview": "vite preview"
  },
  "dependencies": {
    "@react-three/cannon": "^6.5.2",
    "@react-three/drei": "^9.88.0",
    "@react-three/fiber": "^8.15.11",
    "@types/three": "^0.158.0",
    "cannon-es": "^0.20.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "three": "^0.158.0",
    "zustand": "^4.4.6"
  },
  "devDependencies": {
    "@eslint/js": "^9.21.0",
    "@types/react": "^18.2.55",
    "@types/react-dom": "^18.2.19",
    "@typescript-eslint/eslint-plugin": "^8.26.0",
    "@typescript-eslint/parser": "^8.26.0",
    "@vitejs/plugin-react": "^4.3.4",
    "eslint": "^9.21.0",
    "eslint-config-prettier": "^10.0.2",
    "eslint-plugin-prettier": "^5.2.3",
    "eslint-plugin-react-hooks": "^5.1.0",
    "eslint-plugin-react-refresh": "^0.4.19",
    "globals": "^15.15.0",
    "prettier": "^3.5.3",
    "typescript": "~5.7.2",
    "typescript-eslint": "^8.24.1",
    "vite": "^6.2.0"
  }
}

================
File: README.md
================
# Wolfenstein 3D-Inspired FPS

A modern first-person shooter game inspired by Wolfenstein 3D, built with React, Three.js, and TypeScript. The game features classic maze-like levels, hit-scan combat, and straightforward enemy AI with modern visual enhancements.

## Features

- Classic WASD movement with mouse look
- Hit-scan combat system
- Enemy AI with states (Idle, Chase, Attack, Death)
- Interactive objects (keys, doors, switches)
- Dynamic lighting and post-processing effects
- Grid-based level design
- HUD with health, ammo, and score tracking

## Tech Stack

- React 18 with TypeScript
- Three.js for 3D rendering
- React Three Fiber for React integration
- Cannon.js for physics
- Zustand for state management
- Vite for build tooling

## Getting Started

1. Clone the repository
2. Install dependencies:
   ```bash
   npm install
   ```
3. Start the development server:
   ```bash
   npm run dev
   ```
4. Open your browser and navigate to the URL shown in the terminal

## Development

- `src/components/` - Reusable UI and 3D components
- `src/scenes/` - Level and scene definitions
- `src/state/` - Zustand store and game state logic
- `src/assets/` - Textures, models, and sounds

## Controls

- WASD - Movement
- Mouse - Look around
- Left Click - Shoot
- 1-3 - Switch weapons
- ESC - Pause game

## License

MIT

================
File: spec.md
================
# Developer Specification: Wolfenstein 3D–Inspired FPS

## 1. Project Overview

**Concept:**  
Develop a first-person shooter inspired by Wolfenstein 3D, targeted for modern desktop browsers. The game combines classic maze-like levels, hit-scan combat, and straightforward enemy AI with modern visual enhancements, dynamic lighting, high-resolution textures, and post-processing effects. The game is session-based (no save/load), with handcrafted levels defined using a grid-based layout, and features a HUD that displays health, ammo, keys, and score.

---

## 2. Requirements

### Gameplay Features

- **Player Movement & Controls:**

  - Classic WASD movement with mouse look (using pointer lock).
  - Collision detection prevents passing through walls.
  - Game-over state when health reaches zero, with a restart option.

- **Combat:**

  - **Player Shooting:**
    - Implemented via hit-scan using Three.js’s Raycaster.
    - Immediate damage and visual feedback (e.g., muzzle flash, impact sparks).
  - **Enemy Shooting:**
    - Enemies also use hit-scan shooting toward the player with cooldowns.

- **Enemy AI:**

  - States: Idle, Chase, Attack, and Death.
  - Enemies remain idle until the player is in detection range, then chase and attack with hit-scan shooting.
  - On death, trigger animations and remove enemies from active gameplay.

- **Interactive Objects:**

  - Keys, switches, doors, and secret passages.
  - Trigger zones using collision detection; when collided, update game state (e.g., collect key, open door).
  - Door animations via AnimationMixer or tweening.

- **Weapon Management & Pickups:**

  - Weapon switching via key mapping (e.g., 1=pistol, 2=machine gun, 3=shotgun).
  - Collision-based pickups for health, ammo, and keys that update game state.

- **HUD & Scoring:**

  - Overlay displaying player health, ammo count, keys collected, and score.
  - Score based on enemy kills and level completion time.
  - Real-time state updates using a global state manager.

- **Level Design:**

  - Handcrafted, maze-like levels defined by a grid-based layout.
  - Levels represented as 2D arrays or JSON files mapping cells (e.g., 0 = empty, 1 = wall, 2 = door, 3 = key).
  - Parsing these grids to instantiate corresponding 3D objects in the scene.
  - Static geometry for walls and floors integrated with physics for collision.

- **Visual & Audio Enhancements:**
  - Dynamic lighting (directional, ambient, point lights) with shadows.
  - High-resolution textures using PBR materials, normal/bump maps.
  - Post-processing effects (bloom, tone mapping, SSAO, vignette) via react-postprocessing.
  - Particle effects for muzzle flashes, impact sparks, and enemy death animations.
  - Spatial sound effects (no background music).

### Technical Requirements

- **Target Platforms:**  
  Modern desktop browsers.

- **Performance:**
  - Asynchronous asset loading using Suspense and react-three-fiber’s useLoader.
  - Optimization through texture compression, glTF asset optimization (gltf-pipeline or glTF-Transform), and potential texture atlasing.

---

## 3. Architecture Choices

### Frontend & Rendering

- **Framework:** React with TypeScript.
- **3D Rendering:**
  - **react-three-fiber:** Declarative Three.js integration.
  - **Three.js:** Core rendering engine.
  - **react-three/drei:** Pre-built helpers (camera controls, loaders, debug tools).

### State Management

- **Zustand:**  
  Lightweight, global state manager for player stats, enemy states, inventory, and HUD updates.

### Physics & Collision

- **cannon-es:**  
  Physics engine.
- **@react-three/cannon:**  
  Integration of cannon-es with react-three-fiber to manage collisions for walls, player, and interactive triggers.

### Asset Pipeline

- **Models & Textures:**
  - glTF/glb format for models (with embedded animations).
  - Tools: gltf-pipeline/glTF-Transform for model optimization.
  - Sharp and imagemin for texture compression (WebP/JPEG).
  - Optional: Texture atlasing tools (e.g., TexturePacker).

### UI & Styling

- **CSS Modules:**  
  For scoped, maintainable styling of HUDs, menus, and overlays.

### Build & Deployment

- **Bundler:** Vite (or Create React App with TypeScript) for efficient builds, hot reloading, and module bundling.
- **Deployment:** Static hosting on platforms like Vercel, Netlify, or GitHub Pages.
- **Version Control & CI/CD:** Git with optional GitHub Actions for continuous integration.

---

## 4. Data Handling

### Level Data

- **Format:**  
  Define levels as 2D arrays or JSON files. Example:
  ```json
  {
    "grid": [
      [1, 1, 1, 1, 1],
      [1, 0, 0, 3, 1],
      [1, 0, 1, 0, 1],
      [1, 2, 0, 0, 1],
      [1, 1, 1, 1, 1]
    ],
    "enemies": [{ "position": [2, 1], "type": "grunt" }]
  }
  ```
- **Parsing:**  
  A dedicated React component (e.g., `<LevelGrid>`) loops over the grid, mapping cell values to 3D objects with predefined positions (using a consistent cell size).

### Asset Loading

- **Approach:**  
  Use react-three-fiber’s **useLoader** and React’s **Suspense** to load models and textures asynchronously.
- **Optimization:**  
  Implement texture compression and model optimization as part of the build process.

---

## 5. Error Handling Strategies

### Code-Level Error Handling

- **TypeScript:**  
  Use strict type-checking to prevent runtime errors.
- **Component Boundaries:**  
  Use React error boundaries to catch errors in rendering and display fallback UI if needed.

### Collision & Game State

- **Collision Events:**  
  Wrap collision callbacks (e.g., onCollide in interactive objects) with try/catch to handle unexpected errors without crashing the game loop.
- **State Management:**  
  Ensure Zustand state updates are atomic and validate inputs to avoid inconsistent states.

### Logging & Debugging

- **Browser Console:**  
  Log errors and warnings during development.
- **In-Game Debug Tools:**  
  Integrate tools like react-three/drei’s Stats and Leva for runtime monitoring of performance and state.
- **Optional:**  
  Integrate an error tracking service (e.g., Sentry) in production to capture and report runtime errors.

---

## 6. Testing Plan

### Manual Testing

- **Gameplay Testing:**  
  Regularly play through levels to ensure that:
  - Player movement and collision work correctly.
  - Enemy AI transitions (idle, chase, attack, death) perform as expected.
  - Interactive objects (keys, doors, switches) trigger correctly on collision.
  - HUD updates accurately reflect game state.
- **Level Design:**  
  Verify that levels parsed from grid data render correctly and that enemy placements, pickups, and interactive elements are balanced.

### Debugging Tools

- **In-Game Debug Overlays:**  
  Use Stats (FPS) and collision visualization helpers to monitor performance and physics interactions.
- **Leva Panel:**  
  Toggle debug parameters and adjust game variables in real time to fine-tune gameplay.

### Automated Testing (Optional / Future Considerations)

- **Unit Tests:**  
  While initial testing is manual, consider writing unit tests for critical functions (such as level data parsing, state updates in Zustand, and collision callback functions) using Jest.
- **Integration Tests:**  
  For core game logic, you might use React Testing Library to simulate events and verify state changes, though this is secondary given the graphical nature of the project.

---

## 7. Developer Workflow & Milestones

### Setup & Initial Development

- **Environment Setup:**  
  Configure React with TypeScript, react-three-fiber, Zustand, and cannon-es. Ensure Vite (or CRA) is configured for hot reloading and module bundling.
- **Basic Scene & Player:**  
  Develop the basic Three.js scene, implement player movement with collision detection, and set up the camera with pointer lock.
- **Grid-Based Level Prototype:**  
  Create a simple grid-based level using hardcoded data to render walls, doors, and pickups.

### Core Mechanics Implementation

- **Combat System:**  
  Implement hit-scan shooting for the player and enemies using Three.js’s Raycaster.
- **Enemy AI:**  
  Develop the state machine for enemy behavior and integrate basic animations.
- **Interactive Objects:**  
  Integrate collision triggers for keys and doors, updating game state via Zustand.
- **HUD & UI:**  
  Build the HUD overlay using React and CSS Modules; integrate state updates for health, ammo, keys, and score.

### Visual Polish & Enhancements

- **Lighting & Materials:**  
  Enhance the scene with dynamic lighting, shadows, and high-res textures.
- **Post-Processing Effects:**  
  Integrate react-postprocessing for bloom, tone mapping, and ambient occlusion.
- **Particle Effects:**  
  Implement muzzle flashes and impact effects.

### Finalization & Testing

- **Iterative Playtesting:**  
  Conduct thorough manual testing across levels, ensuring smooth gameplay and balanced difficulty.
- **Error Handling & Logging:**  
  Add error boundaries, robust collision handling, and logging mechanisms.
- **Optimization & Deployment:**  
  Optimize asset loading, bundle size, and deploy the game on a static hosting service.

================
File: tsconfig.app.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src"]
}

================
File: tsconfig.json
================
{
  "files": [],
  "references": [
    { "path": "./tsconfig.app.json" },
    { "path": "./tsconfig.node.json" }
  ]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})



================================================================
End of Codebase
================================================================
